# Homework Plan Builder

Write a library for building object storage operation plans. The idea is that you can build an execution plan (the query "code") using structures and afterwards evaluate it, which “makes everything happen”. This is best described with an example.

Let’s assume that we have an object storage bucket *papaya*, which contains the object *my_amazin_object* whose content is 
```
abcdefghijklmnoprstvuwzabcdefghijklmnoprstvuwz
```
We also have the environment variable *TARGET_OBJECT_ID* set to *transformed_amazin_object*
```go
func main() {
	var minioCli *minio.Client
	// Init minio client.

	plan := &ObjectSaver{
		Source: &Concatenate{
			Parts: []Object{
				&Repeat{
					Source: &Take{
						Source: &ObjectFromSource{
							Bucket: &IDVariable{
								Variable: &IDConstant{
									ID: "amazin_bucket",
								},
							},
							ID: &IDConstant{
								ID: ID("my_amazin_object"),
							},
							Source: &MinioObjectSource{},
						},
						N: 16,
					},
					Times: 5,
				},
				&ObjectVariable{
					Variable: &IDConstant{
						ID: "amazin_data",
					},
				},
			},
		},
		Bucket: &IDConstant{
			ID: ID("papaya"),
		},
		ID: IDFn(func(context EvaluationContext) (ID, error) {
			return ID(os.Getenv("TARGET_OBJECT_ID")), nil
		}),
		Target: &MinioObjectStore{},
	}
	if err := plan.Evaluate(EvaluationContext{
		MinioClient: minioCli,
		Variables: map[string]interface{}{
			"amazin_bucket": "papaya",
			"amazin_data":   []byte("bacon"),
		},
		/* ...whatever initialization you need... */
	}); err != nil {
		log.Fatal(err)
	}
}
```

On evaluation, this should read the *my_amazin_object* object from the minio source. Take the first 16 bytes of it. Repeat the resulting content 5 times, concatenate it with “bacon”, finally creating a new *transformed_amazin_object* object in the *papaya* bucket with the content:
```
abcdefghijklmnopabcdefghijklmnopabcdefghijklmnopabcdefghijklmnopabcdefghijklmnopbacon
```

The above code (with possible minor modifications) should work connected with a local Minio instance.

Make sure to design extensible and composable interfaces. Feel free to operate on byte slices instead of readers (you can always call ioutil.ReadAll to turn a reader into a byte slice if you need), optimization isn't important here.

Write a table test (as is generated by Goland or VS Code, but you can obviously write it by yourself) which checks at least 3 different scenarios (additional tests aren’t at all necessary, but you can write as many as you want).
